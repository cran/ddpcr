<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Dean Attali" />

<meta name="date" content="2026-01-14" />

<title>Extending ddpcr by adding new plate types</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Extending ddpcr by adding new plate
types</h1>
<h4 class="author">Dean Attali</h4>
<h4 class="date">2026-01-14</h4>



<div id="extending-ddpcr-by-adding-new-plate-types" class="section level1">
<h1>Extending ddpcr by adding new plate types</h1>
<p>While this package was developed as a tool to facilitate the analysis
of some specific types of ddPCR data, it was implemented in a way that
easily allows users to add custom ddPCR plate types through <em>S3
inheritance</em> (see <a href="./technical_details.Rmd">the
<em>Technical details</em> vignette</a> for more details). The basic
concept is that every plate type has a parent plate type, from which it
inherits all features, but can be made more specific or add/modify its
behaviour. Inheritance is transitive (features are inherited from all
ancestors, not only the most immediate one), but a plate can only have
one parent (multiple inheritance is not supported).</p>
<div id="default-plate-type-ddpcr_plate" class="section level2">
<h2>Default plate type: ddpcr_plate</h2>
<p>The most basic plate type is <code>ddpcr_plate</code>, and every
plate type inherits from it, either directly or by inheriting from other
plate types that are descendants of <code>ddpcr_plate</code>. This is
handy because it means that all functionality that is common to all
ddPCR types is implemented once for <code>ddpcr_plate</code> and can be
used by all plate types, unless a plate type specifically removes or
modifies some behaviour. Every plate type by default inherits all
methods that <code>ddpcr_plate</code> has, which can be found by running
<code>methods(class = &quot;ddpcr_plate&quot;)</code>. If you create a new plate
type and no parent is specified, or if you initialize a ddPCR plate
without specifying a plate type, then <code>ddpcr_plate</code> is
assumed.</p>
<p>Calling the <code>analyze()</code> function on any plate will result
in running the ddPCR data through a series of <em>steps</em> that are
defined for the given plate type, and the droplets in the data will be
assigned to one of several <em>clusters</em> associated with the given
plate type.</p>
<p>Plates of type <code>ddpcr_plate</code> have 4 possible clusters:
<code>UNDEFINED</code> for any droplet that has not been assigned a
cluster yet, <code>FAILED</code> for droplets in failed wells,
<code>OUTLIER</code> for outlier droplets, and <code>EMPTY</code> for
droplets without any template in them. This information can also be seen
with the <code>clusters()</code> function.</p>
<p>Plates of type <code>ddpcr_plate</code> have 4 analysis steps:
<code>INITIALIZE</code>, <code>REMOVE_FAILURES</code>,
<code>REMOVE_OUTLIERS</code>, and <code>REMOVE_EMPTY</code>. This means
that any plate that is created will perform these basic steps of
removing failed wells, outlier droplets, and empty droplets. The exact
functions used for each step can be seen with the <code>steps()</code>
function. For example,
<code>new_plate(sample_data_dir()) %&gt;% steps</code> will reveal that
the <code>REMOVE_FAILURES</code> steps calls the function
<code>remove_failures()</code>, so you can view the algorithm by running
<code>ddpcr:::remove_failures.ddpcr_plate</code>.</p>
<p>Plates of type <code>ddpcr_plate</code> also have a set of parameters
that can be viewed with the <code>params()</code> function. Running
<code>new_plate(sample_data_dir()) %&gt;% params %&gt;% str</code> will
show all the default parameters that are used. Any of these parameters
can be overridden in new plate types, and new parameters can be
added.</p>
</div>
<div id="built-in-plate-types" class="section level2">
<h2>Built-in plate types</h2>
<p>The default plate type is the common base for all built-in types, but
because it is not specific to any particular ddPCR data, it does not do
any droplet gating, as that is highly dependent on the type of data. The
default type is useful for pre-processing, exploring, and visualizing
any ddPCR data. There are other built-in plate types available, and you
can see a list through the <code>plate_types</code> variable. You can
learn more about the built-in plate types and what kind of ddPCR data is
suitable for each one by viewing its documentation with
<code>?plate_types</code>. If none of the built-in plate types are
useful for your data, you can create a new plate type with custom
analysis steps or parameters.</p>
</div>
<div id="functions-to-implement-when-adding-a-new-plate-type" class="section level2">
<h2>Functions to implement when adding a new plate type</h2>
<p>If you want to add a new plate type, there are a few functions you
need to implement. All these functions take one argument: a
<code>ddpcr_plate</code> object. Note that all these functions are S3
generics, so you need to follow the S3 method naming scheme.</p>
<div id="parent_plate_type-define-parent-plate-type" class="section level3">
<h3><code>parent_plate_type()</code>: Define parent plate type</h3>
<p>Each ddPCR plate has a “parent” plate type from which it inherits all
its properties. When creating a custom plate type, you should define
this function and simply return the parent plate type. If you don’t
define this function, the parent plate type is assumed to be the base
type of <code>ddpcr_plate</code>. Inheriting from a parent plate means
that the same cluster types, analysis steps, and parameters will be used
by default.</p>
</div>
<div id="define_params-define-plate-type-parameters" class="section level3">
<h3><code>define_params()</code>: Define plate type parameters</h3>
<p>Every ddPCR plate type has a set of default parameters. When creating
a custom plate type, if your plate type needs a different set of
parameters than its parent type, you must define this function and have
it return the parameters specific to this plate. When defining this
function, you can use <code>NextMethod(&quot;define_params&quot;)</code> to get a
list of the parameters of the parent type so that you can simply add to
that list rather than redefining all the parameters.</p>
</div>
<div id="define_clusters-define-droplet-clusters" class="section level3">
<h3><code>define_clusters()</code>: Define droplet clusters</h3>
<p>Every ddPCR plate type has a set of potential clusters the droplets
can be assigned to. When creating a custom plate type, if your plate
type uses a different set of clusters than its parent type, you must
define this function and have it return the cluster names. When defining
this function, you can use <code>NextMethod(&quot;define_clusters&quot;)</code> to
get a list of the clusters available in the parent type if you want to
simply add new clusters without defining all of them.</p>
</div>
<div id="define_steps-define-analysis-steps" class="section level3">
<h3><code>define_steps()</code>: Define analysis steps</h3>
<p>Every ddPCR plate type has an ordered set of steps that are run to
analyze the data. When creating a new plate type, if your plate type has
different analysis steps than its parent type, you must define this
function and have it return a named list of the analysis steps. When
defining this function, you can use
<code>NextMethod(&quot;define_steps&quot;)</code> to get a list of the steps
available in the parent type if you want to simply add new steps without
defining all of them. Any step that you define must have an associated
function with the same name that takes a ddPCR plate as an argument and
returns the ddPCR plate after running the given step on it. Most
analysis steps will usually change the plate’s metadata
(<code>?plate_meta</code>) and the droplet cluster assignments
(<code>?plate_data</code>). See the example below for helper functions
that are available when writing code for an analysis step.</p>
</div>
<div id="changing-the-algorithm-of-an-existing-step" class="section level3">
<h3>Changing the algorithm of an existing step</h3>
<p>With the <code>define_steps()</code> function you can define new
analysis steps that are unique to your new plate type. It can also be
desirable to simply change the implementation of an existing step
instead of creating a new step. For example, any ddPCR plate will, by
default, use the <code>ddpcr:::remove_failures.ddpcr_plate</code>
function as the algorithm for flagging failed wells. If your plate type
has a specific way of flagging failed wells, you can overwrite this step
by defining a new S3 generic function for your plate type.</p>
</div>
<div id="plot-plot-a-ddpcr-plate" class="section level3">
<h3><code>plot()</code>: Plot a ddPCR plate</h3>
<p>The default plot function provided by <code>ddpcr_plate</code> will
usually be enough to convey your ddPCR plate information. If there is
anything specific you want to add to plots of your new plate type, you
can define this function. It is recommended to build on top of the
output of the default plot function, rather than start a complete new
plot. This can be done by having the first line of code being
<code>p &lt;- NextMethod(&quot;plot&quot;)</code> and adding plot elements on top
of <code>p</code>. Note that <code>ggplot2</code> is the default
plotting library. Read the help section of the default plot to learn
more <code>?plot.ddpcr_plate</code>.</p>
</div>
</div>
<div id="example" class="section level2">
<h2>Example</h2>
<p>As a simple exercise to show how easy it is to create a new plate
type, this section will walk through the steps required to create a new
plate type. The name of the new plate type is <code>fam_border</code>.
In experiments of this type, we are interested in running the typical
pre-processing (identify failed wells, outlier droplets, and empty
droplets), followed by simply classifying the remaining droplets as
either FAM-positive or FAM-negative, with the border between positive
and negative being a predefined value. This plate type is clearly not
very useful but it is good for demonstration purposes.</p>
<p>The first thing to do is to define the parent plate type, which in
this case will be <code>ddpcr_plate</code>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a>parent_plate_type.fam_border <span class="ot">&lt;-</span> <span class="cf">function</span>(plate) {</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>  <span class="st">&quot;ddpcr_plate&quot;</span></span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a>}</span></code></pre></div>
<p>The next step is to define the parameters of this plate type. ddPCR
plates of this type are expected to have at least 14,000 droplets per
well as a QA metric. If any well has fewer droplets, it is considered a
failure. There is already a parameter for this, so we just need to
modify it. We also add a new parameter for the border to use for gating
the droplets, and give it a default value.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>define_params.fam_border <span class="ot">&lt;-</span> <span class="cf">function</span>(plate) {</span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>  params <span class="ot">&lt;-</span> <span class="fu">NextMethod</span>(<span class="st">&quot;define_params&quot;</span>)</span>
<span id="cb2-3"><a href="#cb2-3" tabindex="-1"></a>  </span>
<span id="cb2-4"><a href="#cb2-4" tabindex="-1"></a>  new_params <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb2-5"><a href="#cb2-5" tabindex="-1"></a>    <span class="st">&#39;REMOVE_FAILURES&#39;</span> <span class="ot">=</span> <span class="fu">list</span>(</span>
<span id="cb2-6"><a href="#cb2-6" tabindex="-1"></a>      <span class="st">&#39;TOTAL_DROPS_T&#39;</span> <span class="ot">=</span> <span class="dv">14000</span>  <span class="co"># overwriting an existing parameter</span></span>
<span id="cb2-7"><a href="#cb2-7" tabindex="-1"></a>    ),</span>
<span id="cb2-8"><a href="#cb2-8" tabindex="-1"></a>    <span class="st">&#39;GATE&#39;</span> <span class="ot">=</span> <span class="fu">list</span>(</span>
<span id="cb2-9"><a href="#cb2-9" tabindex="-1"></a>      <span class="st">&#39;FAM_BORDER&#39;</span> <span class="ot">=</span> <span class="dv">5000</span>  <span class="co"># defining a new parameter</span></span>
<span id="cb2-10"><a href="#cb2-10" tabindex="-1"></a>    )</span>
<span id="cb2-11"><a href="#cb2-11" tabindex="-1"></a>  )</span>
<span id="cb2-12"><a href="#cb2-12" tabindex="-1"></a>  params <span class="ot">&lt;-</span> <span class="fu">modifyList</span>(params, new_params)</span>
<span id="cb2-13"><a href="#cb2-13" tabindex="-1"></a>  </span>
<span id="cb2-14"><a href="#cb2-14" tabindex="-1"></a>  params</span>
<span id="cb2-15"><a href="#cb2-15" tabindex="-1"></a>}</span></code></pre></div>
<p>Next we define the potential droplet clusters. We use the same
clusters as the default plate type and add two more, to denote droplets
in the FAM-positive and FAM-negative sections.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>define_clusters.fam_border <span class="ot">&lt;-</span> <span class="cf">function</span>(plate) {</span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>  clusters <span class="ot">&lt;-</span> <span class="fu">NextMethod</span>(<span class="st">&quot;define_clusters&quot;</span>)</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>  </span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a>  <span class="fu">c</span>(clusters,</span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a>    <span class="st">&#39;FAM_POSITIVE&#39;</span>,</span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a>    <span class="st">&#39;FAM_NEGATIVE&#39;</span></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a>  )</span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a>}</span></code></pre></div>
<p>Next we define the analysis steps. We use all the default analysis
steps (pre-processing steps), and add a gating step.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a>define_steps.fam_border <span class="ot">&lt;-</span> <span class="cf">function</span>(plate) {</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>  steps <span class="ot">&lt;-</span> <span class="fu">NextMethod</span>(<span class="st">&quot;define_steps&quot;</span>)</span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>  </span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>  <span class="fu">c</span>(steps,</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>    <span class="fu">list</span>(</span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>      <span class="st">&#39;GATE&#39;</span> <span class="ot">=</span> <span class="st">&#39;gate_droplets&#39;</span></span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a>    ))</span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a>}</span></code></pre></div>
<p>We need to create the <code>gate_droplets</code> function with the
actual logic that will perform the step. Notice the use of the following
helper functions that are especially useful when writing analysis step
functions: <code>step</code>, <code>check_step</code>,
<code>step_begin</code>, <code>step_end</code>,
<code>unanalyzed_clusters</code>, and <code>status</code>. You can look
up the documentation for each of these functions to learn more.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>gate_droplets <span class="ot">&lt;-</span> <span class="cf">function</span>(plate) {</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>  <span class="co"># make sure this step was not called prematurely</span></span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>  current_step <span class="ot">&lt;-</span> <span class="fu">step</span>(plate, <span class="st">&#39;GATE&#39;</span>)</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>  <span class="fu">check_step</span>(plate, current_step)  </span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>  </span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>  <span class="co"># show an informative message to the user</span></span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>  <span class="fu">step_begin</span>(<span class="st">&quot;Classifying droplets as FAM-positive or negative&quot;</span>)</span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a>  </span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a>  data <span class="ot">&lt;-</span> <span class="fu">plate_data</span>(plate)</span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a>  border <span class="ot">&lt;-</span> <span class="fu">params</span>(plate, <span class="st">&#39;GATE&#39;</span>, <span class="st">&#39;FAM_BORDER&#39;</span>)</span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a>  </span>
<span id="cb5-12"><a href="#cb5-12" tabindex="-1"></a>  <span class="co"># get a list of clusters that have not been considered yet in the analysis</span></span>
<span id="cb5-13"><a href="#cb5-13" tabindex="-1"></a>  <span class="co"># this is useful so that we only look at droplets that have not yet been</span></span>
<span id="cb5-14"><a href="#cb5-14" tabindex="-1"></a>  <span class="co"># assigned to a cluster</span></span>
<span id="cb5-15"><a href="#cb5-15" tabindex="-1"></a>  unanalyzed_clusters <span class="ot">&lt;-</span> <span class="fu">unanalyzed_clusters</span>(plate, <span class="st">&#39;FAM_POSITIVE&#39;</span>)</span>
<span id="cb5-16"><a href="#cb5-16" tabindex="-1"></a>  </span>
<span id="cb5-17"><a href="#cb5-17" tabindex="-1"></a>  <span class="co"># get the indices of all droplets that are FAM-positive and negative</span></span>
<span id="cb5-18"><a href="#cb5-18" tabindex="-1"></a>  unanalyzed_idx <span class="ot">&lt;-</span> data<span class="sc">$</span>cluster <span class="sc">%in%</span> unanalyzed_clusters</span>
<span id="cb5-19"><a href="#cb5-19" tabindex="-1"></a>  fam_pos <span class="ot">&lt;-</span> unanalyzed_idx <span class="sc">&amp;</span> data<span class="sc">$</span>FAM <span class="sc">&gt;=</span> border</span>
<span id="cb5-20"><a href="#cb5-20" tabindex="-1"></a>  fam_neg <span class="ot">&lt;-</span> unanalyzed_idx <span class="sc">&amp;</span> data<span class="sc">$</span>FAM <span class="sc">&lt;</span> border</span>
<span id="cb5-21"><a href="#cb5-21" tabindex="-1"></a>  </span>
<span id="cb5-22"><a href="#cb5-22" tabindex="-1"></a>  <span class="co"># assign each droplet to its cluster</span></span>
<span id="cb5-23"><a href="#cb5-23" tabindex="-1"></a>  data[fam_pos, <span class="st">&#39;cluster&#39;</span>] <span class="ot">&lt;-</span> <span class="fu">cluster</span>(plate, <span class="st">&#39;FAM_POSITIVE&#39;</span>)</span>
<span id="cb5-24"><a href="#cb5-24" tabindex="-1"></a>  data[fam_neg, <span class="st">&#39;cluster&#39;</span>] <span class="ot">&lt;-</span> <span class="fu">cluster</span>(plate, <span class="st">&#39;FAM_NEGATIVE&#39;</span>)</span>
<span id="cb5-25"><a href="#cb5-25" tabindex="-1"></a>  </span>
<span id="cb5-26"><a href="#cb5-26" tabindex="-1"></a>  <span class="co"># update the data on the plate object</span></span>
<span id="cb5-27"><a href="#cb5-27" tabindex="-1"></a>  <span class="fu">plate_data</span>(plate) <span class="ot">&lt;-</span> data</span>
<span id="cb5-28"><a href="#cb5-28" tabindex="-1"></a>  </span>
<span id="cb5-29"><a href="#cb5-29" tabindex="-1"></a>  <span class="co"># record how many drops in each well are in each cluster</span></span>
<span id="cb5-30"><a href="#cb5-30" tabindex="-1"></a>  <span class="co"># and add this info to the plate&#39;s metadata</span></span>
<span id="cb5-31"><a href="#cb5-31" tabindex="-1"></a>  drops_per_cluster <span class="ot">&lt;-</span> </span>
<span id="cb5-32"><a href="#cb5-32" tabindex="-1"></a>    plyr<span class="sc">::</span><span class="fu">ddply</span>(data, <span class="sc">~</span> well, <span class="cf">function</span>(x) {</span>
<span id="cb5-33"><a href="#cb5-33" tabindex="-1"></a>      <span class="fu">data.frame</span>(</span>
<span id="cb5-34"><a href="#cb5-34" tabindex="-1"></a>        <span class="st">&#39;drops_positive&#39;</span> <span class="ot">=</span> <span class="fu">sum</span>(x<span class="sc">$</span>cluster <span class="sc">==</span> <span class="fu">cluster</span>(plate, <span class="st">&#39;FAM_POSITIVE&#39;</span>)),</span>
<span id="cb5-35"><a href="#cb5-35" tabindex="-1"></a>        <span class="st">&#39;drops_negative&#39;</span> <span class="ot">=</span> <span class="fu">sum</span>(x<span class="sc">$</span>cluster <span class="sc">==</span> <span class="fu">cluster</span>(plate, <span class="st">&#39;FAM_NEGATIVE&#39;</span>))</span>
<span id="cb5-36"><a href="#cb5-36" tabindex="-1"></a>      )</span>
<span id="cb5-37"><a href="#cb5-37" tabindex="-1"></a>    })</span>
<span id="cb5-38"><a href="#cb5-38" tabindex="-1"></a>  <span class="fu">plate_meta</span>(plate) <span class="ot">&lt;-</span></span>
<span id="cb5-39"><a href="#cb5-39" tabindex="-1"></a>    dplyr<span class="sc">::</span><span class="fu">left_join</span>(</span>
<span id="cb5-40"><a href="#cb5-40" tabindex="-1"></a>      <span class="fu">plate_meta</span>(plate),</span>
<span id="cb5-41"><a href="#cb5-41" tabindex="-1"></a>      drops_per_cluster,</span>
<span id="cb5-42"><a href="#cb5-42" tabindex="-1"></a>      <span class="at">by =</span> <span class="st">&quot;well&quot;</span></span>
<span id="cb5-43"><a href="#cb5-43" tabindex="-1"></a>    )</span>
<span id="cb5-44"><a href="#cb5-44" tabindex="-1"></a>  </span>
<span id="cb5-45"><a href="#cb5-45" tabindex="-1"></a>  <span class="co"># VERY IMPORTANT - do not forget to update the status of the plate</span></span>
<span id="cb5-46"><a href="#cb5-46" tabindex="-1"></a>  <span class="fu">status</span>(plate) <span class="ot">&lt;-</span> current_step</span>
<span id="cb5-47"><a href="#cb5-47" tabindex="-1"></a>  <span class="fu">step_end</span>()</span>
<span id="cb5-48"><a href="#cb5-48" tabindex="-1"></a>  </span>
<span id="cb5-49"><a href="#cb5-49" tabindex="-1"></a>  plate</span>
<span id="cb5-50"><a href="#cb5-50" tabindex="-1"></a>}</span></code></pre></div>
<p>Now the new plate type is ready to be used. We can also add a plot
function if there are any customizations to the plot that are specific
to this plate type. The default plot function of ddPCR plates goes a
long way, but one thing we can add is a line showing the division
border.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a>plot.fam_border <span class="ot">&lt;-</span> <span class="cf">function</span>(x, ..., <span class="at">show_border =</span> <span class="cn">FALSE</span>) {</span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>  <span class="co"># Plot a regular ddpcr plate</span></span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a>  p <span class="ot">&lt;-</span> <span class="fu">NextMethod</span>(<span class="st">&quot;plot&quot;</span>, x)</span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a>  </span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a>  <span class="co"># Show the custom thresholds</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a>  <span class="cf">if</span> (show_border) {</span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a>    border <span class="ot">&lt;-</span> <span class="fu">params</span>(x, <span class="st">&#39;GATE&#39;</span>, <span class="st">&#39;FAM_BORDER&#39;</span>)</span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a>    p <span class="ot">&lt;-</span> p <span class="sc">+</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a>      ggplot2<span class="sc">::</span><span class="fu">geom_hline</span>(<span class="at">yintercept =</span> border)</span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a>  }</span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a>  </span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a>  p</span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>}</span></code></pre></div>
<p>The one last thing we can add is a convenient way for the user to set
the border parameter.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="st">`</span><span class="at">fam_border&lt;-</span><span class="st">`</span> <span class="ot">&lt;-</span> <span class="cf">function</span>(plate, value) {</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>  <span class="fu">params</span>(plate, <span class="st">&#39;GATE&#39;</span>, <span class="st">&#39;FAM_BORDER&#39;</span>) <span class="ot">&lt;-</span> value</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>  plate</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>}</span></code></pre></div>
<p>Now we can create a new ddPCR plate with the new type and run a full
analysis of it.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="fu">library</span>(ddpcr)</span></code></pre></div>
<pre><code>## 
## Attaching package: &#39;ddpcr&#39;</code></pre>
<pre><code>## The following object is masked from &#39;package:stats&#39;:
## 
##     step</code></pre>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>plate <span class="ot">&lt;-</span> <span class="fu">new_plate</span>(<span class="at">dir =</span> <span class="fu">sample_data_dir</span>(), <span class="at">type =</span> <span class="st">&quot;fam_border&quot;</span>)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a><span class="fu">fam_border</span>(plate) <span class="ot">&lt;-</span> <span class="dv">8000</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>plate <span class="ot">&lt;-</span> <span class="fu">analyze</span>(plate)</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a><span class="fu">plot</span>(plate, <span class="at">show_drops_empty =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## Warning: `aes_string()` was deprecated in ggplot2 3.0.0.
## ℹ Please use tidy evaluation idioms with `aes()`.
## ℹ See also `vignette(&quot;ggplot2-in-packages&quot;)` for more information.
## ℹ The deprecated feature was likely used in the ddpcr package.
##   Please report the issue at &lt;https://github.com/daattali/ddpcr/issues&gt;.
## This warning is displayed once per session.
## Call `lifecycle::last_lifecycle_warnings()` to see where this warning was
## generated.</code></pre>
<pre><code>## Warning in ggplot2::geom_rect(data = dplyr::filter(meta_used, !.data[[&quot;success&quot;]]), : All aesthetics have length 1, but the data has 2 rows.
## ℹ Please consider using `annotate()` or provide this layer with data containing
##   a single row.</code></pre>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a><span class="fu">plot</span>(plate, <span class="at">col_drops_fam_negative =</span> <span class="st">&quot;red&quot;</span>,</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a>     <span class="at">col_drops_fam_positive =</span> <span class="st">&quot;blue&quot;</span>, <span class="at">show_border =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>## Warning in ggplot2::geom_rect(data = dplyr::filter(meta_used, !.data[[&quot;success&quot;]]), : All aesthetics have length 1, but the data has 2 rows.
## ℹ Please consider using `annotate()` or provide this layer with data containing
##   a single row.</code></pre>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="fu">plate_meta</span>(plate, <span class="at">only_used =</span> <span class="cn">TRUE</span>)</span></code></pre></div>
<pre><code>##   well sample row col used    target_ch1     target_ch2 drops success
## 1  A01   Dean   A   1 TRUE Consensus_FAM WTspecific_HEX 15820    TRUE
## 2  C01   Mike   C   1 TRUE Consensus_FAM WTspecific_HEX 14256    TRUE
## 3  F05   Mary   F   5 TRUE Consensus_FAM WTspecific_HEX 15377    TRUE
## 4  A05   Dave   A   5 TRUE Consensus_FAM WTspecific_HEX 13165   FALSE
## 5  C05  Emily   C   5 TRUE Consensus_FAM WTspecific_HEX 14109   FALSE
##   drops_outlier drops_empty drops_non_empty drops_empty_fraction concentration
## 1             2       13690            2130                0.865           170
## 2             0       12879            1377                0.903           120
## 3             0       14126            1251                0.919            99
## 4             1          NA              NA                   NA            NA
## 5             0          NA              NA                   NA            NA
##   drops_positive drops_negative
## 1           1889            239
## 2           1281             96
## 3           1090            161
## 4              0              0
## 5              0              0</code></pre>
<p><img role="img" aria-label src="data:image/png;base64,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" alt width="50%" /><img role="img" aria-label src="data:image/png;base64,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" alt width="50%" /></p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
